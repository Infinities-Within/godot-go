package godot

import (
	"github.com/gabstv/godot-go/gdnative"
)

/*------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "class.go.tmpl" so they can be included in the generated
//   code.
//----------------------------------------------------------------------------*/

//func NewKinematicBodyFromPointer(ptr gdnative.Pointer) KinematicBody {
func newKinematicBodyFromPointer(ptr gdnative.Pointer) KinematicBody {
	owner := gdnative.NewObjectFromPointer(ptr)
	obj := KinematicBody{}
	obj.SetBaseObject(owner)

	return obj
}

/*
Undocumented
*/
type KinematicBody struct {
	PhysicsBody
	owner gdnative.Object
}

func (o *KinematicBody) BaseClass() string {
	return "KinematicBody"
}

/*
        Undocumented
	Args: [{ false axis int}], Returns: bool
*/
func (o *KinematicBody) GetAxisLock(axis gdnative.Int) gdnative.Bool {
	//log.Println("Calling KinematicBody.GetAxisLock()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(axis)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("KinematicBody", "get_axis_lock")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: Vector3
*/
func (o *KinematicBody) GetFloorNormal() gdnative.Vector3 {
	//log.Println("Calling KinematicBody.GetFloorNormal()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("KinematicBody", "get_floor_normal")

	// Call the parent method.
	// Vector3
	retPtr := gdnative.NewEmptyVector3()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector3FromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: Vector3
*/
func (o *KinematicBody) GetFloorVelocity() gdnative.Vector3 {
	//log.Println("Calling KinematicBody.GetFloorVelocity()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("KinematicBody", "get_floor_velocity")

	// Call the parent method.
	// Vector3
	retPtr := gdnative.NewEmptyVector3()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector3FromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: float
*/
func (o *KinematicBody) GetSafeMargin() gdnative.Real {
	//log.Println("Calling KinematicBody.GetSafeMargin()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("KinematicBody", "get_safe_margin")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyReal()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRealFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [{ false slide_idx int}], Returns: KinematicCollision
*/
func (o *KinematicBody) GetSlideCollision(slideIdx gdnative.Int) KinematicCollisionImplementer {
	//log.Println("Calling KinematicBody.GetSlideCollision()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(slideIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("KinematicBody", "get_slide_collision")

	// Call the parent method.
	// KinematicCollision
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newKinematicCollisionFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(KinematicCollisionImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "KinematicCollision" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(KinematicCollisionImplementer)
	}

	return &ret
}

/*
        Undocumented
	Args: [], Returns: int
*/
func (o *KinematicBody) GetSlideCount() gdnative.Int {
	//log.Println("Calling KinematicBody.GetSlideCount()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("KinematicBody", "get_slide_count")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: bool
*/
func (o *KinematicBody) IsOnCeiling() gdnative.Bool {
	//log.Println("Calling KinematicBody.IsOnCeiling()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("KinematicBody", "is_on_ceiling")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: bool
*/
func (o *KinematicBody) IsOnFloor() gdnative.Bool {
	//log.Println("Calling KinematicBody.IsOnFloor()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("KinematicBody", "is_on_floor")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: bool
*/
func (o *KinematicBody) IsOnWall() gdnative.Bool {
	//log.Println("Calling KinematicBody.IsOnWall()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("KinematicBody", "is_on_wall")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [{ false rel_vec Vector3} {True true infinite_inertia bool} {True true exclude_raycast_shapes bool} {False true test_only bool}], Returns: KinematicCollision
*/
func (o *KinematicBody) MoveAndCollide(relVec gdnative.Vector3, infiniteInertia gdnative.Bool, excludeRaycastShapes gdnative.Bool, testOnly gdnative.Bool) KinematicCollisionImplementer {
	//log.Println("Calling KinematicBody.MoveAndCollide()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 4, 4)
	ptrArguments[0] = gdnative.NewPointerFromVector3(relVec)
	ptrArguments[1] = gdnative.NewPointerFromBool(infiniteInertia)
	ptrArguments[2] = gdnative.NewPointerFromBool(excludeRaycastShapes)
	ptrArguments[3] = gdnative.NewPointerFromBool(testOnly)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("KinematicBody", "move_and_collide")

	// Call the parent method.
	// KinematicCollision
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newKinematicCollisionFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(KinematicCollisionImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "KinematicCollision" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(KinematicCollisionImplementer)
	}

	return &ret
}

/*
        Undocumented
	Args: [{ false linear_velocity Vector3} {(0, 0, 0) true up_direction Vector3} {False true stop_on_slope bool} {4 true max_slides int} {0.785398 true floor_max_angle float} {True true infinite_inertia bool}], Returns: Vector3
*/
func (o *KinematicBody) MoveAndSlide(linearVelocity gdnative.Vector3, upDirection gdnative.Vector3, stopOnSlope gdnative.Bool, maxSlides gdnative.Int, floorMaxAngle gdnative.Real, infiniteInertia gdnative.Bool) gdnative.Vector3 {
	//log.Println("Calling KinematicBody.MoveAndSlide()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 6, 6)
	ptrArguments[0] = gdnative.NewPointerFromVector3(linearVelocity)
	ptrArguments[1] = gdnative.NewPointerFromVector3(upDirection)
	ptrArguments[2] = gdnative.NewPointerFromBool(stopOnSlope)
	ptrArguments[3] = gdnative.NewPointerFromInt(maxSlides)
	ptrArguments[4] = gdnative.NewPointerFromReal(floorMaxAngle)
	ptrArguments[5] = gdnative.NewPointerFromBool(infiniteInertia)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("KinematicBody", "move_and_slide")

	// Call the parent method.
	// Vector3
	retPtr := gdnative.NewEmptyVector3()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector3FromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [{ false linear_velocity Vector3} { false snap Vector3} {(0, 0, 0) true up_direction Vector3} {False true stop_on_slope bool} {4 true max_slides int} {0.785398 true floor_max_angle float} {True true infinite_inertia bool}], Returns: Vector3
*/
func (o *KinematicBody) MoveAndSlideWithSnap(linearVelocity gdnative.Vector3, snap gdnative.Vector3, upDirection gdnative.Vector3, stopOnSlope gdnative.Bool, maxSlides gdnative.Int, floorMaxAngle gdnative.Real, infiniteInertia gdnative.Bool) gdnative.Vector3 {
	//log.Println("Calling KinematicBody.MoveAndSlideWithSnap()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 7, 7)
	ptrArguments[0] = gdnative.NewPointerFromVector3(linearVelocity)
	ptrArguments[1] = gdnative.NewPointerFromVector3(snap)
	ptrArguments[2] = gdnative.NewPointerFromVector3(upDirection)
	ptrArguments[3] = gdnative.NewPointerFromBool(stopOnSlope)
	ptrArguments[4] = gdnative.NewPointerFromInt(maxSlides)
	ptrArguments[5] = gdnative.NewPointerFromReal(floorMaxAngle)
	ptrArguments[6] = gdnative.NewPointerFromBool(infiniteInertia)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("KinematicBody", "move_and_slide_with_snap")

	// Call the parent method.
	// Vector3
	retPtr := gdnative.NewEmptyVector3()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector3FromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [{ false axis int} { false lock bool}], Returns: void
*/
func (o *KinematicBody) SetAxisLock(axis gdnative.Int, lock gdnative.Bool) {
	//log.Println("Calling KinematicBody.SetAxisLock()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(axis)
	ptrArguments[1] = gdnative.NewPointerFromBool(lock)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("KinematicBody", "set_axis_lock")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false pixels float}], Returns: void
*/
func (o *KinematicBody) SetSafeMargin(pixels gdnative.Real) {
	//log.Println("Calling KinematicBody.SetSafeMargin()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromReal(pixels)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("KinematicBody", "set_safe_margin")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false from Transform} { false rel_vec Vector3} {True true infinite_inertia bool}], Returns: bool
*/
func (o *KinematicBody) TestMove(from gdnative.Transform, relVec gdnative.Vector3, infiniteInertia gdnative.Bool) gdnative.Bool {
	//log.Println("Calling KinematicBody.TestMove()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromTransform(from)
	ptrArguments[1] = gdnative.NewPointerFromVector3(relVec)
	ptrArguments[2] = gdnative.NewPointerFromBool(infiniteInertia)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("KinematicBody", "test_move")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

// KinematicBodyImplementer is an interface that implements the methods
// of the KinematicBody class.
type KinematicBodyImplementer interface {
	PhysicsBodyImplementer
	GetAxisLock(axis gdnative.Int) gdnative.Bool
	GetFloorNormal() gdnative.Vector3
	GetFloorVelocity() gdnative.Vector3
	GetSafeMargin() gdnative.Real
	GetSlideCollision(slideIdx gdnative.Int) KinematicCollisionImplementer
	GetSlideCount() gdnative.Int
	IsOnCeiling() gdnative.Bool
	IsOnFloor() gdnative.Bool
	IsOnWall() gdnative.Bool
	MoveAndCollide(relVec gdnative.Vector3, infiniteInertia gdnative.Bool, excludeRaycastShapes gdnative.Bool, testOnly gdnative.Bool) KinematicCollisionImplementer
	MoveAndSlide(linearVelocity gdnative.Vector3, upDirection gdnative.Vector3, stopOnSlope gdnative.Bool, maxSlides gdnative.Int, floorMaxAngle gdnative.Real, infiniteInertia gdnative.Bool) gdnative.Vector3
	MoveAndSlideWithSnap(linearVelocity gdnative.Vector3, snap gdnative.Vector3, upDirection gdnative.Vector3, stopOnSlope gdnative.Bool, maxSlides gdnative.Int, floorMaxAngle gdnative.Real, infiniteInertia gdnative.Bool) gdnative.Vector3
	SetAxisLock(axis gdnative.Int, lock gdnative.Bool)
	SetSafeMargin(pixels gdnative.Real)
	TestMove(from gdnative.Transform, relVec gdnative.Vector3, infiniteInertia gdnative.Bool) gdnative.Bool
}
